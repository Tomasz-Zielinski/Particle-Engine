{"id":"src/ParticleEngine.ts","dependencies":[{"name":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\tsconfig.json","includedInParent":true,"mtime":1549650964128},{"name":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\package.json","includedInParent":true,"mtime":1549759490260},{"name":"./VertexShader","loc":{"line":10,"column":29},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\VertexShader.ts"},{"name":"./FragmentShader","loc":{"line":11,"column":31},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\FragmentShader.ts"},{"name":"three","loc":{"line":12,"column":33},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar VertexShader_1 = require(\"./VertexShader\");\n\nvar FragmentShader_1 = require(\"./FragmentShader\");\n\nvar THREE = __importStar(require(\"three\"));\n\nvar ParticleEngine =\n/** @class */\nfunction () {\n  function ParticleEngine() {\n    this.position = new THREE.Color();\n    this.velocity = new THREE.Vector3();\n    this.color = new THREE.Vector3();\n    this.time = 0;\n    this.particles = 0;\n    this.max = 10000;\n    this.count = 0;\n    THREE.Object3D.apply(this);\n    var textureLoader = new THREE.TextureLoader();\n    this.texture = textureLoader.load('particle.png');\n    this.material = new THREE.ShaderMaterial({\n      depthTest: false,\n      depthWrite: false,\n      uniforms: {},\n      vertexShader: VertexShader_1.VertexShader,\n      fragmentShader: FragmentShader_1.FragmentShader\n    });\n    this.geometry = new THREE.BufferGeometry();\n    this.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.particles * 3), 3));\n    this.geometry.addAttribute('positionStart', new THREE.BufferAttribute(new Float32Array(this.particles * 3), 3));\n    this.geometry.addAttribute('startTime', new THREE.BufferAttribute(new Float32Array(this.particles), 1));\n    this.geometry.addAttribute('velocity', new THREE.BufferAttribute(new Float32Array(this.particles * 3), 3));\n    this.geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this.particles * 3), 3));\n    this.geometry.addAttribute('size', new THREE.BufferAttribute(new Float32Array(this.particles), 1));\n    this.geometry.addAttribute('life', new THREE.BufferAttribute(new Float32Array(this.particles), 1));\n    this.add(new THREE.Points(this.geometry, this.material));\n  }\n\n  return ParticleEngine;\n}();\n\nParticleEngine.prototype.spawn = function () {\n  var positionStart = this.geometry.getAttribute('positionStart');\n  var startTime = this.geometry.getAttribute('startTime');\n  var velocity = this.geometry.getAttribute('velocity');\n  var color = this.geometry.getAttribute('color');\n  var size = this.geometry.getAttribute('size');\n  var life = this.geometry.getAttribute('life');\n  var i = this.particles; // Position\n\n  positionStart.array[i * 3 + 0] = this.position.x + Math.random();\n  positionStart.array[i * 3 + 1] = this.position.y + Math.random();\n  positionStart.array[i * 3 + 2] = this.position.z + Math.random(); // Velocity\n\n  var maxVel = 2;\n  var velX = velocity.x + Math.random();\n  var velY = velocity.y + Math.random();\n  var velZ = velocity.z + Math.random();\n  velocity.array[i * 3 + 0] = THREE.Math.clamp((velX - -maxVel) / (maxVel - -maxVel), 0, 1);\n  ;\n  velocity.array[i * 3 + 1] = THREE.Math.clamp((velY - -maxVel) / (maxVel - -maxVel), 0, 1);\n  ;\n  velocity.array[i * 3 + 2] = THREE.Math.clamp((velZ - -maxVel) / (maxVel - -maxVel), 0, 1);\n  ; // Color\n\n  color.r = THREE.Math.clamp(color.r + Math.random(), 0, 1);\n  color.g = THREE.Math.clamp(color.g + Math.random(), 0, 1);\n  color.b = THREE.Math.clamp(color.b + Math.random(), 0, 1);\n  color.array[i * 3 + 0] = color.r;\n  color.array[i * 3 + 1] = color.g;\n  color.array[i * 3 + 2] = color.b; // Size\n\n  size.array[i] = size + Math.random();\n  life.array[i] = life;\n  startTime.array[i] = this.time + Math.random() * 2e-2;\n  this.count++;\n  this.particles++;\n  if (this.particles > this.max) this.particles = 0;\n};\n\nParticleEngine.prototype.update = function (time) {\n  this.time = time;\n  this.material.uniforms.uTime = time;\n  var positionStart = this.geometry.getAttribute('positionStart');\n  var timeStart = this.geometry.getAttribute('timeStart');\n  var velocity = this.geometry.getAttribute('velocity');\n  var color = this.geometry.getAttribute('color');\n  var size = this.geometry.getAttribute('size');\n  var life = this.geometry.getAttribute('life');\n  positionStart.needsUpdate = true;\n  timeStart.needsUpdate = true;\n  velocity.needsUpdate = true;\n  color.needsUpdate = true;\n  size.needsUpdate = true;\n  life.needsUpdate = true;\n  this.count = 0;\n};\n\nParticleEngine.prototype = Object.create(THREE.Object3D.prototype);"},"hash":"a233c95f55378637e48f1ae5a892cd02","cacheData":{"env":{}}}