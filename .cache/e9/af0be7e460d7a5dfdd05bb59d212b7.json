{"id":"src/ParticleEngine.ts","dependencies":[{"name":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\tsconfig.json","includedInParent":true,"mtime":1549650964128},{"name":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\package.json","includedInParent":true,"mtime":1551013880037},{"name":"three","loc":{"line":10,"column":33},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\node_modules\\three\\build\\three.module.js"},{"name":"./VertexShader","loc":{"line":11,"column":29},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\VertexShader.ts"},{"name":"./FragmentShader","loc":{"line":12,"column":31},"parent":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\ParticleEngine.ts","resolved":"C:\\Users\\Asaris\\Desktop\\Asaris\\Programming\\ParticleEngine\\src\\FragmentShader.ts"}],"generated":{"js":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __importStar(require(\"three\"));\n\nvar VertexShader_1 = require(\"./VertexShader\");\n\nvar FragmentShader_1 = require(\"./FragmentShader\");\n\nvar ParticleEngine =\n/** @class */\nfunction () {\n  function ParticleEngine() {\n    this.position = new THREE.Vector3();\n    this.velocity = new THREE.Vector3();\n    this.color = new THREE.Color();\n    this.limit = 1000000;\n    this.particles = 0;\n    this.count = 0;\n    this.time = 0;\n    this.constructor();\n  }\n\n  return ParticleEngine;\n}();\n\nParticleEngine.prototype = Object.create(THREE.Object3D.prototype);\n\nParticleEngine.prototype.constructor = function () {\n  THREE.Object3D.apply(this);\n  var textureLoader = new THREE.TextureLoader();\n  var particleSpriteTex = textureLoader.load('particle2.png');\n  this.material = new THREE.ShaderMaterial({\n    uniforms: {\n      'uTime': {\n        value: 0.0\n      },\n      'uScale': {\n        value: 1.0\n      },\n      'tSprite': {\n        value: particleSpriteTex\n      }\n    }\n  });\n  this.material.depthWrite = false;\n  this.material.vertexShader = VertexShader_1.VertexShader;\n  this.material.fragmentShader = FragmentShader_1.FragmentShader;\n  this.material.blending = THREE.NoBlending;\n  this.geometry = new THREE.BufferGeometry();\n  this.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.limit * 3), 3));\n  this.geometry.addAttribute('positionStart', new THREE.BufferAttribute(new Float32Array(this.limit * 3), 3));\n  this.geometry.addAttribute('startTime', new THREE.BufferAttribute(new Float32Array(this.limit), 1));\n  this.geometry.addAttribute('velocity', new THREE.BufferAttribute(new Float32Array(this.limit * 3), 3));\n  this.geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this.limit * 3), 3));\n  this.geometry.addAttribute('size', new THREE.BufferAttribute(new Float32Array(this.limit), 1));\n  this.geometry.addAttribute('life', new THREE.BufferAttribute(new Float32Array(this.limit), 1));\n  this.add(new THREE.Points(this.geometry, this.material));\n};\n\nParticleEngine.prototype.spawn = function (options) {\n  var positionStartAttribute = this.geometry.getAttribute('positionStart');\n  var startTimeAttribute = this.geometry.getAttribute('startTime');\n  var velocityAttribute = this.geometry.getAttribute('velocity');\n  var colorAttribute = this.geometry.getAttribute('color');\n  var sizeAttribute = this.geometry.getAttribute('size');\n  var lifeAttribute = this.geometry.getAttribute('life');\n  options = options || {};\n  this.position = options.position !== undefined ? this.position.copy(options.position) : this.position.set(0, 0, 0);\n  this.velocity = new THREE.Vector3();\n  this.color = this.color.set(0xff0000);\n  var positionRandomness = options.positionRandomness || 0;\n  var velocityRandomness = options.velocityRandomness || 0;\n  var colorRandomness = options.colorRandomness || 1;\n  var life = options.life || 5;\n  var size = options.size || 10;\n  var sizeRandomness = options.sizeRandomness || 0;\n  var i = this.particles; // Position\n\n  positionStartAttribute.array[i * 3 + 0] = this.position.x + Math.random() * positionRandomness;\n  positionStartAttribute.array[i * 3 + 1] = this.position.y + Math.random() * positionRandomness;\n  positionStartAttribute.array[i * 3 + 2] = this.position.z + Math.random() * positionRandomness; // Velocity\n\n  var maxVel = 2;\n  var velX = this.velocity.x + Math.random() * velocityRandomness;\n  var velY = this.velocity.y + Math.random() * velocityRandomness;\n  var velZ = this.velocity.z + Math.random() * velocityRandomness;\n  velX = THREE.Math.clamp((velX - -maxVel) / (maxVel - -maxVel), 0, 1);\n  velY = THREE.Math.clamp((velY - -maxVel) / (maxVel - -maxVel), 0, 1);\n  velZ = THREE.Math.clamp((velZ - -maxVel) / (maxVel - -maxVel), 0, 1);\n  velocityAttribute.array[i * 3 + 0] = velX;\n  velocityAttribute.array[i * 3 + 1] = velY;\n  velocityAttribute.array[i * 3 + 2] = velZ; // Color\n\n  this.color.r = THREE.Math.clamp(this.color.r + Math.random() * colorRandomness, 0, 1);\n  this.color.g = THREE.Math.clamp(this.color.g + Math.random() * colorRandomness, 0, 1);\n  this.color.b = THREE.Math.clamp(this.color.b + Math.random() * colorRandomness, 0, 1);\n  colorAttribute.array[i * 3 + 0] = this.color.r;\n  colorAttribute.array[i * 3 + 1] = this.color.g;\n  colorAttribute.array[i * 3 + 2] = this.color.b; // turbulence, size, life and starttime\n\n  sizeAttribute.array[i] = size + Math.random() * sizeRandomness;\n  lifeAttribute.array[i] = life;\n  startTimeAttribute.array[i] = this.time + Math.random() * 2e-2; // Count\n\n  this.particles++;\n  this.count++;\n  if (this.particles >= this.limit) this.particles = 0;\n};\n\nParticleEngine.prototype.update = function (time) {\n  this.time = time;\n  this.material.uniforms.uTime.value = time;\n  this.geometry.getAttribute('positionStart').needsUpdate = true;\n  this.geometry.getAttribute('startTime').needsUpdate = true;\n  this.geometry.getAttribute('velocity').needsUpdate = true;\n  this.geometry.getAttribute('color').needsUpdate = true;\n  this.geometry.getAttribute('size').needsUpdate = true;\n  this.geometry.getAttribute('life').needsUpdate = true;\n  this.count = 0;\n};\n\nexports.default = ParticleEngine;"},"hash":"685c397799467b0189eb891e501b115c","cacheData":{"env":{}}}